

/*
   Sanctuary.ino -- part of the Sanctuary project.

   This example was actually generated (by Druid Builder) and
   created as part of the builder tutorial series.

   It includes a few commands, a number of input requests and
   submenus... you can see the whole process of creating the
   system in the learning section of the devicedruid.com site
    https://devicedruid.com/learn-more/learn-druid-builder/


   Connect using serial terminal or device druid @ 57600 bps
   or whatever you set serial_baud_rate in SanctuarySettings.h
   


   Copyright (C) 2017 Pat Deegan, psychogenic.com

   Generated by DruidBuilder [https://devicedruid.com/]

   Druid4Arduino, Device Druid, Druid Builder, the builder
   code brewery and its wizards, SerialUI and supporting
   libraries, as well as the generated parts of this program
   are
              Copyright (C) 2013-2017 Pat Deegan
   [http://psychogenic.com/ | http://flyingcarsandstuff.com/]
   and distributed under the terms of their respective licenses.
   See http://devicedruid.com for details.


   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
   THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
   PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE,
   YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
   CORRECTION.

   Keep in mind that there is no warranty and you are solely
   responsible for the use of all these cool tools.

   Play safe, have fun.

*/


/* we need the SerialUI lib */
#include <SerialUI.h>
#include "SanctuarySettings.h"

/* our project specific types and functions are here */
#include "Sanctuary.h"



/*
   You have access to:

 * *** MySUI -- the SerialUI instance.
   Use it as you would the Serial device, e.g.
  	MySUI.println(F("Helloooo..."));


 * *** MyInputs -- a container for
   values submitted by users. Contents:

      MyInputs.WebCam (bool)
      MyInputs.SaltTanks (long int)
      MyInputs.FreshTanks (long int)
      MyInputs.Lighting (bool)
      MyInputs.Fountains (long int)
      MyInputs.Lamp (long int)



 * *** MyTracked -- a container for values tracked
   by druid and displayed to users in "state" pane.  Changes to:

      MyTracked.Counter (unsigned long)
      MyTracked.Office (float)
      MyTracked.Outter (unsigned long)
      MyTracked.LowLev (bool)
      MyTracked.TigerFood (unsigned long)

   will automatically be reported to the UI, on the next refresh/ping.


*/


/* **** standard setup() function **** */
void setup() {

  // SetupSerialUI() is a generated function that does just that.
  // have a look at setup.cpp to see how SerialUI is configured
  // for all the menus and requests/commands...

  if (!SetupSerialUI()) {
    DIE_HORRIBLY(F("Problem during setup"));
  }
  // we want our tracking to reflect actual
  // stock levels
  MyTracked.TigerFood = Stock.level(TIGER_FOOD);

  // We're using SPI just to simulate managing a
  // sensor or something
  SPI.begin();


}


void loop() {

  /* We checkForUser() periodically, to see
  ** if anyone is attempting to send us some
  ** data through SerialUI.
  **
  ** This code checks at every pass of the main
  ** loop, meaning a user can interact with the
  ** system at any time.  Should you want to
  ** check for user access only once (say have a
  ** N second wait on startup, and then forgo
  ** allowing SerialUI access), then increase the
  ** delay parameter and use checkForUserOnce(), e.g.
  **
  **    mySUI.checkForUserOnce(15000);
  **
  ** to allow 15 seconds to connect on startup only.
  **
  ** Called without parameters, or with 0, checkForUser
  ** won't delay the program, as it won't block at all.
  ** Using a parameter > 0:
  **	checkForUser(MAX_MS);
  ** will wait for up to MAX_MS milliseconds for a user,
  ** so is equivalent to having a delay(MAX_MS) in the loop,
  ** when no user is present.
  */

  // as described in the tutorial video, we want to call
  // a management function periodically.
  // The heartbeat function will handle this while users are
  // connected.

  // so this call to checkForUser has a parameter, and is therefore
  // blocking (for heartbeat_function_period_ms millis)
  if (MySUI.checkForUser(heartbeat_function_period_ms)) {

    /* Now we keep handling the serial user's
    ** requests until they exit or timeout.
    */
    while (MySUI.userPresent()) {
      // actually respond to requests, using
      MySUI.handleRequests();

      // you could add a quick task here, to perform
      // after *every* request, but it's better to use
      // the setUserPresenceHeartbeat-related methods
    }
  } else {
    // when no one is connected, we do our 
    // maintenance 'manually'
    doMaintenanceStuff();
  }


}


